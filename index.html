<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Make a Brainrot Combo Explorer - Limited Combos</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    margin: 20px;
  }
  h1 {
    text-align: center;
    color: #ff55aa;
  }
  .breadcrumb {
    margin-bottom: 15px;
  }
  .breadcrumb span {
    cursor: pointer;
    color: #ff77cc;
    text-decoration: underline;
  }
  .breadcrumb span:hover {
    color: #ff33aa;
  }
  .container {
    max-width: 700px;
    margin: auto;
    background: #1b1b1b;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 0 25px #ff33aa88;
  }
  .pet-title {
    font-size: 1.5em;
    margin-bottom: 10px;
  }
  .emoji {
    font-size: 1.7em;
    margin-right: 12px;
    vertical-align: middle;
  }
  ul {
    list-style-type: none;
    padding-left: 20px;
    max-height: 400px;
    overflow-y: auto;
  }
  li {
    margin: 6px 0;
    cursor: pointer;
    transition: color 0.3s;
  }
  li:hover {
    color: #ff33aa;
  }
  .footer {
    text-align: center;
    margin-top: 40px;
    font-size: 0.9em;
    color: #777;
  }
  .parents-list {
    margin-top: 8px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Make a Brainrot Combo Explorer - Limited Combos</h1>
  <div class="breadcrumb"></div>
  <div id="pet-details"></div>
  <h3>All Pets & Combos (click to explore ancestry):</h3>
  <ul id="pet-list"></ul>
</div>
<div class="footer">
  Rules:<br />
  - Base pets (level 0) can combine with base pets or combos (level 1 or 2).<br />
  - Level 1 combos combine only with base pets.<br />
  - Level 2 combos do not combine further.<br />
  - Max combo level = 2.<br />
  Click an item to see its parents.<br />
  Breadcrumb navigation included.
</div>

<script>
// Base pets list
const basePets = [
  { name: "Tralalero Tralala", emoji: "ðŸ¦ˆ" },
  { name: "Bombardiro Crocodilo", emoji: "ðŸŠ" },
  { name: "Tung Sahur", emoji: "ðŸ¥" },
  { name: "LirilÃ¬ LarilÃ ", emoji: "ðŸŒµ" },
  { name: "Boneca Ambalabu", emoji: "ðŸ¸" },
  { name: "Brr Brr Patapim", emoji: "ðŸŒ³" },
  { name: "Chimpanzini Bananini", emoji: "ðŸŒ" },
  { name: "Bombombini Gusini", emoji: "âœˆï¸" },
  { name: "Capuccino Assassino", emoji: "â˜•" },
  { name: "Trippi Troppi", emoji: "ðŸ»" },
  { name: "Frigo Camelo", emoji: "ðŸª" },
  { name: "La Vaca Saturno Saturnita", emoji: "ðŸª" },
  { name: "Ballerina Cappucina", emoji: "ðŸ’ƒ" },
  { name: "U Din Din Din Dun", emoji: "ðŸŠ" },
  { name: "Frulli Frulla", emoji: "âœ¨" },
  { name: "Skibidi Toilet", emoji: "ðŸš½" },
];

// Master dictionary of all pets and combos
// Format: { name, emoji, parents: [], level }
let combos = {};

// Initialize combos with base pets (level 0)
for (const pet of basePets) {
  combos[pet.name] = {
    name: pet.name,
    emoji: pet.emoji,
    parents: [],
    level: 0,
  };
}

// Helper to create a unique sorted key from two names
function parentsKey(name1, name2) {
  return [name1, name2].sort().join(" + ");
}

// Combine two pets/combos into a new combo respecting rules
function combine(a, b) {
  // Avoid duplicate combos
  const key = parentsKey(a.name, b.name);
  if (combos[key]) return null;

  // Determine new combo level (max parents level + 1)
  const comboLevel = Math.max(a.level, b.level) + 1;
  if (comboLevel > 2) return null; // max level 2 combos only

  // Combination rules:
  // Level 2 combos can't combine further
  if (a.level === 2 || b.level === 2) return null;

  // Level 1 combos only combine with level 0 pets
  if (a.level === 1 && b.level === 1) return null;

  // Allow:
  // - level 0 + level 0
  // - level 0 + level 1
  // - level 1 + level 0

  const newCombo = {
    name: key,
    emoji: a.emoji + "âž•" + b.emoji,
    parents: [a.name, b.name],
    level: comboLevel,
  };

  combos[key] = newCombo;
  return newCombo;
}

// Generate combos with above rules
function generateCombos() {
  let currentLayer = Object.values(combos);
  for (let depth = 1; depth <= 3; depth++) {
    let newCombosThisRound = [];
    for (const a of currentLayer) {
      for (const b of Object.values(combos)) {
        if (a.name === b.name) continue;

        const key = parentsKey(a.name, b.name);
        if (combos[key]) continue;

        const newCombo = combine(a, b);
        if (newCombo) newCombosThisRound.push(newCombo);
      }
    }
    if (newCombosThisRound.length === 0) break;
    currentLayer = newCombosThisRound;
  }
}

generateCombos();

// UI setup
const breadcrumbDiv = document.querySelector(".breadcrumb");
const petDetailsDiv = document.getElementById("pet-details");
const petList = document.getElementById("pet-list");

let path = [];

function createClickable(text, onClick) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.cursor = "pointer";
  span.style.color = "#ff77cc";
  span.style.textDecoration = "underline";
  span.onclick = onClick;
  span.onmouseenter = () => (span.style.color = "#ff33aa");
  span.onmouseleave = () => (span.style.color = "#ff77cc");
  return span;
}

function updateBreadcrumb() {
  breadcrumbDiv.innerHTML = "";
  const home = createClickable("Home", () => {
    path = [];
    showPetList();
  });
  breadcrumbDiv.appendChild(home);

  path.forEach((node, i) => {
    const sep = document.createTextNode(" > ");
    breadcrumbDiv.appendChild(sep);
    const span = createClickable(node.name, () => {
      path = path.slice(0, i + 1);
      showPetDetails(path[i].name);
    });
    breadcrumbDiv.appendChild(span);
  });
}

function showPetList() {
  updateBreadcrumb();
  petDetailsDiv.innerHTML = "<em>Select a pet or combo below to explore ancestry.</em>";
  petList.innerHTML = "";

  // Sort by level, then name
  const allPets = Object.values(combos).sort((a, b) => {
    if (a.level !== b.level) return a.level - b.level;
    return a.name.localeCompare(b.name);
  });

  for (const pet of allPets) {
    const li = document.createElement("li");
    li.innerHTML = `<span class="emoji">${pet.emoji}</span>${pet.name} <small style="color:#888;">(Level ${pet.level})</small>`;
    li.onclick = () => {
      path = [{ name: pet.name }];
      showPetDetails(pet.name);
    };
    petList.appendChild(li);
  }
}

function showPetDetails(name) {
  updateBreadcrumb();

  const pet = combos[name];
  if (!pet) {
    petDetailsDiv.textContent = "Unknown pet/combo.";
    return;
  }

  petDetailsDiv.innerHTML = "";
  const title = document.createElement("div");
  title.className = "pet-title";
  title.innerHTML = `<span class="emoji">${pet.emoji}</span><strong>${pet.name}</strong>`;
  petDetailsDiv.appendChild(title);

  if (pet.parents.length === 0) {
    const baseNote = document.createElement("div");
    baseNote.style.fontStyle = "italic";
    baseNote.textContent = "This is a base/original pet â€” no parents.";
    petDetailsDiv.appendChild(baseNote);
    return;
  }

  const parentsTitle = document.createElement("div");
  parentsTitle.textContent = "Formed by combining these two parents:";
  parentsTitle.style.marginTop = "10px";
  petDetailsDiv.appendChild(parentsTitle);

  const ul = document.createElement("ul");
  ul.className = "parents-list";
  pet.parents.forEach((parentName) => {
    const parent = combos[parentName];
    if (!parent) return;
    const li = document.createElement("li");
    li.innerHTML = `<span class="emoji">${parent.emoji}</span>${parent.name} <small style="color:#888;">(Level ${parent.level})</small>`;
    li.onclick = () => {
      path.push({ name: parent.name });
      showPetDetails(parent.name);
    };
    ul.appendChild(li);
  });
  petDetailsDiv.appendChild(ul);
}

// Initial display
showPetList();

</script>
</body>
</html>
