<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Make a Brainrot Infinite Combo Explorer</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    margin: 20px;
  }
  h1 {
    text-align: center;
    color: #ff55aa;
  }
  .breadcrumb {
    margin-bottom: 15px;
  }
  .breadcrumb span {
    cursor: pointer;
    color: #ff77cc;
    text-decoration: underline;
  }
  .breadcrumb span:hover {
    color: #ff33aa;
  }
  .container {
    max-width: 700px;
    margin: auto;
    background: #1b1b1b;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 0 25px #ff33aa88;
  }
  .pet-title {
    font-size: 1.5em;
    margin-bottom: 10px;
  }
  .emoji {
    font-size: 1.7em;
    margin-right: 12px;
    vertical-align: middle;
  }
  ul {
    list-style-type: none;
    padding-left: 20px;
  }
  li {
    margin: 6px 0;
    cursor: pointer;
    transition: color 0.3s;
  }
  li:hover {
    color: #ff33aa;
  }
  .footer {
    text-align: center;
    margin-top: 40px;
    font-size: 0.9em;
    color: #777;
  }
  .parents-list {
    margin-top: 8px;
  }
</style>
</head>
<body>
<div class="container">
  <h1>Make a Brainrot Infinite Combo Explorer</h1>
  <div class="breadcrumb"></div>
  <div id="pet-details"></div>
  <h3>All Pets & Combos (click to explore ancestry):</h3>
  <ul id="pet-list"></ul>
</div>
<div class="footer">
  Pets and combos combine pairwise.<br />
  Every pet or combo can combine with every other (including combos).<br />
  Shows ancestry for any combo you click.<br />
  Limited depth for performance.
</div>

<script>
// Base pets
const basePets = [
  { name: "Tralalero Tralala", emoji: "ü¶à" },
  { name: "Bombardiro Crocodilo", emoji: "üêä" },
  { name: "Tung Sahur", emoji: "ü•Å" },
  { name: "Liril√¨ Laril√†", emoji: "üåµ" },
  { name: "Boneca Ambalabu", emoji: "üê∏" },
  { name: "Brr Brr Patapim", emoji: "üå≥" },
  { name: "Chimpanzini Bananini", emoji: "üçå" },
  { name: "Bombombini Gusini", emoji: "‚úàÔ∏è" },
  { name: "Capuccino Assassino", emoji: "‚òï" },
  { name: "Trippi Troppi", emoji: "üêª" },
  { name: "Frigo Camelo", emoji: "üê™" },
  { name: "La Vaca Saturno Saturnita", emoji: "ü™ê" },
  { name: "Ballerina Cappucina", emoji: "üíÉ" },
  { name: "U Din Din Din Dun", emoji: "üçä" },
  { name: "Frulli Frulla", emoji: "‚ú®" },
  { name: "Skibidi Toilet", emoji: "üöΩ" },
];

// Master dictionary of combos: key is sorted parent names joined by " + "
let combos = {};

// Add base pets to combos as "combos" with no parents
for (const pet of basePets) {
  combos[pet.name] = {
    name: pet.name,
    emoji: pet.emoji,
    parents: []
  };
}

// Helper: create key for two parents sorted alphabetically to avoid duplicates
function parentsKey(name1, name2) {
  return [name1, name2].sort().join(" + ");
}

// Combine two pets/combos into a new combo object
function combine(a, b) {
  const key = parentsKey(a.name, b.name);
  if (combos[key]) return null; // already exists

  // New combo name: join parent names with '+'
  const newName = ${a.name} + ${b.name};
  // New emoji: simple concat with plus sign for fun
  const newEmoji = a.emoji + "‚ûï" + b.emoji;

  const newCombo = {
    name: key,
    emoji: newEmoji,
    parents: [a.name, b.name]
  };
  combos[key] = newCombo;
  return newCombo;
}

// Generate combos up to MAX_DEPTH
const MAX_DEPTH = 3;
function generateCombos() {
  let currentLayer = Object.values(combos);
  for (let depth = 1; depth <= MAX_DEPTH; depth++) {
    let newCombosThisRound = [];
    // Combine every pair in currentLayer with every other pet/combo in combos
    for (const a of currentLayer) {
      for (const b of Object.values(combos)) {
        // avoid combining same pair twice and self combo
        if (a.name === b.name) continue;

        const key = parentsKey(a.name, b.name);
        if (combos[key]) continue; // skip if exists

        // Combine
        const newCombo = combine(a, b);
        if (newCombo) {
          newCombosThisRound.push(newCombo);
        }
      }
    }
    if (newCombosThisRound.length === 0) break; // no more combos
    currentLayer = newCombosThisRound;
  }
}

// Run combo generation
generateCombos();

// UI Elements
const breadcrumbDiv = document.querySelector(".breadcrumb");
const petDetailsDiv = document.getElementById("pet-details");
const petList = document.getElementById("pet-list");

let path = [];

// Clickable span helper
function createClickable(text, onClick) {
  const span = document.createElement("span");
  span.textContent = text;
  span.style.cursor = "pointer";
  span.style.color = "#ff77cc";
  span.style.textDecoration = "underline";
  span.onclick = onClick;
  span.onmouseenter = () => (span.style.color = "#ff33aa");
  span.onmouseleave = () => (span.style.color = "#ff77cc");
  return span;
}

// Update breadcrumb UI
function updateBreadcrumb() {
  breadcrumbDiv.innerHTML = "";
  const home = createClickable("Home", () => {
    path = [];
    showPetList();
  });
  breadcrumbDiv.appendChild(home);

  path.forEach((node, i) => {
    const sep = document.createTextNode(" > ");
    breadcrumbDiv.appendChild(sep);
    const span = createClickable(node.name, () => {
      path = path.slice(0, i + 1);
      showPetDetails(path[i].name);
    });
    breadcrumbDiv.appendChild(span);
  });
}

// Show all pets/combos list
function showPetList() {
  updateBreadcrumb();
  petDetailsDiv.innerHTML = "<em>Select a pet or combo below to explore ancestry.</em>";
  petList.innerHTML = "";

  // Sort alphabetically, but put base pets first
  const allPets = Object.values(combos).sort((a, b) => a.name.localeCompare(b.name));

  for (const pet of allPets) {
    const li = document.createElement("li");
    li.innerHTML = <span class="emoji">${pet.emoji}</span>${pet.name};
    li.onclick = () => {
      path = [{ name: pet.name }];
      showPetDetails(pet.name);
    };
    petList.appendChild(li);
  }
}

// Show details and parents of a pet/combo recursively
function showPetDetails(name) {
  updateBreadcrumb();

  const pet = combos[name];
  if (!pet) {
    petDetailsDiv.textContent = "Unknown pet/combo.";
    return;
  }

  petDetailsDiv.innerHTML = "";
  const title = document.createElement("div");
  title.className = "pet-title";
  title.innerHTML = <span class="emoji">${pet.emoji}</span><strong>${pet.name}</strong>;
  petDetailsDiv.appendChild(title);

  if (pet.parents.length === 0) {
    const baseNote = document.createElement("div");
    baseNote.style.fontStyle = "italic";
    baseNote.textContent = "This is a base/original pet ‚Äî no parents.";
    petDetailsDiv.appendChild(baseNote);
    return;
  }

  // Show parents clickable
  const parentsTitle = document.createElement("div");
  parentsTitle.textContent = "Formed by combining these two parents:";
  parentsTitle.style.marginTop = "10px";
  petDetailsDiv.appendChild(parentsTitle);

  const ul = document.createElement("ul");
  ul.className = "parents-list";
  pet.parents.forEach((parentName) => {
    const parent = combos[parentName];
    if (!parent) return;
    const li = document.createElement("li");
    li.innerHTML = <span class="emoji">${parent.emoji}</span>${parent.name};
    li.onclick = () => {
      path.push({ name: parent.name });
      showPetDetails(parent.name);
    };
    ul.appendChild(li);
  });
  petDetailsDiv.appendChild(ul);
}

// Initial display
showPetList();
</script>
</body>
</html>
